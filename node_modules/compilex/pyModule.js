var exec = require('child_process').exec;
var fs = require('fs');
var fetch = require('isomorphic-fetch');
var cuid = require('cuid');
var colors = require('colors');

var userOutput = [];
var testCaseLength = 0;
var userPath = null;
var userLanguage = null;
var userCode = null;
var userModuleId = null;

exports.stats = false;

exports.compilePython = function (envData, code, fn) {

	var filename = cuid.slug();
	path = './temp/';

	fs.writeFile(path + filename + '.py', code, function (err) {
		if (exports.stats) {
			if (err)
				console.log('ERROR: '.red + err);
			else
				console.log('INFO: '.green + filename + '.py created');
		}
		if (!err) {
			var command = 'python ' + path + filename + '.py';
			exec(command, function (error, stdout, stderr) {
				if (error) {
					if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
						var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
						fn(out);
					}
					else {
						if (exports.stats) {
							console.log('INFO: '.green + filename + '.py contained an error while executing');
						}
						var out = { error: stderr };
						fn(out);
					}
				}
				else {
					if (exports.stats) {
						console.log('INFO: '.green + filename + '.py successfully executed !');
					}
					var out = { output: stdout };
					fn(out);
				}
			});
		}
	});
}

exports.compilePythonWithInput = function (envData, code, input, fn) {
	var filename = cuid.slug();
	path = './temp/';

	fs.writeFile(path + filename + '.py', code, function (err) {
		if (exports.stats) {
			if (err)
				console.log('ERROR: '.red + err);
			else
				console.log('INFO: '.green + filename + '.py created');
		}
		if (!err) {

			fs.writeFile(path + filename + 'input.txt', input, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else
						console.log('INFO: '.green + filename + 'input.txt created');
				}
				if (!err) {
					var command = 'python ' + path + filename + '.py < ' + path + filename + 'input.txt ';
					exec(command, function (error, stdout, stderr) {
						if (error) {
							if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
								var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
								fn(out);
							}
							else {
								if (exports.stats) {
									console.log('INFO: '.green + filename + '.py contained an error while executing');
								}
								var out = { error: stderr };
								fn(out);
							}
						}
						else {
							if (exports.stats) {
								console.log('INFO: '.green + filename + '.py successfully executed !');
							}
							var out = { output: stdout };
							fn(out);
						}
					});
				}
			});
		}
	});
}


callCompiler = (exeCommand, filename, progNotFinished, userName, path, i, fn) => {
	exec(exeCommand, function (error, stdout, stderr) {
		if (error) {
			if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
				var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
				// deleteData(path);
				// fn(out);
			}
			else {
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cpp contained an error while executing');
				}
				var out = { error: stderr };
				// deleteData(path);
				// fn(out);
			}
		}
		else {
			if (progNotFinished) {
				progNotFinished = false;
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
				}
				var out = { output: stdout };

				inputfileName = userName + "testcase" + i + "output.txt";
				fs.writeFile(path + "/" + inputfileName, stdout.trim(), function (err) {
					if (exports.stats) {
						if (err)
							console.log('ERROR: '.red + err);
						else {
							console.log('INFO: '.green + inputfileName + ' (inputfileName) created');
							callCompareFunction(path, userName, inputfileName, i, stdout, fn);
						}
					}
				});
				// fn(out);
			}
		}
	});
}

getUserTestCaseOutputPath = (filePathCommandTestCase, outputFilePath, userName, i, testCaseOutput, fn) => {
	var UserTestCasePath = null;
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cpp contained an error while compiling');
			}
			UserTestCasePath = { error: stderr };
			fn(out);
		}
		else {
			UserTestCasePath = stdout.trim();
			finalCompareFunction(UserTestCasePath, outputFilePath, userName, i, testCaseOutput, fn)
			// return UserTestCasePath;
		}
	});
}

getTestCaseOutputPath = (filePathCommandTestCase, userName, i, testCaseOutput, fn) => {
	var outputFilePath = null;
	var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cpp contained an error while compiling');
			}
			outputFilePath = { error: stderr };
			fn(out);
		}
		else {
			outputFilePath = stdout.trim();
			getUserTestCaseOutputPath(filePathCommandTestCaseOutput, outputFilePath, userName, i, testCaseOutput, fn);
			// return outputFilePath;
		}
	});

	// getting the path for the UserName generated file folder
}

finalCompareFunction = (outputFilePath, UserTestCasePath, userName, i, testCaseOutput, fn) => {
	var testCaseOutputFilePath = outputFilePath + "/testcase" + i + "output.txt";
	var UserTestCaseOutputPath = UserTestCasePath + "/" + userName + "testcase" + i + "output.txt";
	// var changeCommand = "cd " + outputFilePath + " && " + ""
	// var input1= "temp/TestCaseOutput/testcase"+i+"output.txt"
	// var input2= "temp/"+userName+"/"+userName+"testcase"+i+"output.txt"
	var command = `diff -q ${testCaseOutputFilePath} ${UserTestCaseOutputPath}`;
	var localarray = {};
	exec(command, function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cpp output did not matched with testcase');
			}
			var out = { error: stderr };
			localarray = {
				testCase: i,
				testStatus: "failed",
				testOutput: testCaseOutput.trim(),
			}
			// deleteData(path);
			// fn(out);
		}
		else {
			var out = stdout;
			console.log(out)
			if (out === '') {
				localarray = {
					testCase: i,
					testStatus: "passed",
					testOutput: testCaseOutput.trim(),
				}

			}
			// logic to calculate the score			
		}
		userOutput.push(localarray);
		// if (userOutput.length === testCaseLength) {
		// 	// userName,moduleId,language,code,output,passedTestCases,TestCases(Total)
		// 	console.log("dayadadf", userOutput);
		// 	var passedData = userOutput.filter((data) => { return data.testStatus === "passed" });
		// 	const URL = "http://172.30.13.201:4000/postUserCodeOutput";
		// 	let fetchData = {
		// 		method: 'POST',
		// 		body: JSON.stringify({
		// 			"userName": "honor",
		// 			"moduleId": "Praleso",
		// 			"language": userLanguage,
		// 			"code": userCode,
		// 			"output": JSON.stringify(userOutput),
		// 			"passedTestCases": passedData.length,
		// 			"testCases": testCaseLength
		// 		}),

		// 		headers: {
		// 			Accept: "application/json",
		// 			"Content-Type": "application/json"
		// 		}
		// 	}
		// 	fetch(URL, fetchData)
		// 		.then(resonse => resonse.json())
		// 		.then((responseJson) => {
		// 			console.log(responseJson);
		// 			var data = '';

		// 			if (responseJson.result) {
		// 				console.log(responseJson.result)
		// 				deleteData(userPath);
		// 				fn(userOutput)
		// 				userOutput = [];
		// 			}
		// 		})
		// 		.catch((err) => {
		// 			console.log(err);
		// 		});

		// }
		if (userOutput.length === testCaseLength) {
			deleteData(userPath);
			fn(userOutput)
			userOutput = [];
		}
	});
}

callCompareFunction = async (path, userName, inputfileName, i, testCaseOutput, fn) => {
	var testCaseOutputPath = "cd temp/TestCaseOutput/testcase" + i + "output.txt";
	var UserOutputPath = path + "/" + inputfileName;
	// var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	var filePathCommandTestCase = "cd temp/" + userName + ' && ' + "pwd"
	var outputFilePath = null;
	var UserTestCasePath = null;

	// getting the path for the TestCaseOutput folder
	outputFilePath = await getTestCaseOutputPath(filePathCommandTestCase, userName, i, testCaseOutput, fn);
	// UserTestCasePath = await getUserTestCaseOutputPath(filePathCommandTestCaseOutput, userName);
}

exports.compilePythonWithTestCase = function (envData, code, userName, language, moduleId, fn) {
	var filename = cuid.slug();
	path = './temp/' + userName;
	userPath = path;
	userLanguage = language;
	userCode = code;
	userModuleId = moduleId;

	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + "/" + userName + '.py', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else {
						console.log('INFO: '.green + filename + '.py created');
						var progNotFinished = true;
						var tempcommand = "cd temp" + "/" + userName + " && " + " python";
						var countOfFileCommand = "cd temp/TestCase" + " && " + "ls | wc -l";
						var filePath = null;
						var filePathcommand = "cd temp/TestCase" + ' && ' + "pwd"
						exec(filePathcommand, function (error, stdout, stderr) {
							if (error) {
								if (exports.stats) {
									console.log('INFO: '.green + userName + '.py contained an error while compiling');
								}
								filePath = { error: stderr };
								// deleteData(path);
								fn(out);
							}
							else {
								filePath = stdout.trim();
								exec(countOfFileCommand, function (error, stdout, stderr) {
									if (error) {
										if (exports.stats) {
											console.log('INFO: '.green + userName + '.py contained an error while compiling');
										}
										var out = { error: stderr };
										// deleteData(path);
										// fn(out);
									}
									else {
										var countOfFile = Number(stdout);
										testCaseLength = countOfFile;
										var i = 1;
										// var command = "cd " + path + " && " + " javac Praleso.java";
										// exec(command, function (error, stdout, stderr) {
										// 	if (error)
										// 		console.log(error)
										// 	else {
										while (i <= countOfFile) {
											var inputfileCommand = filePath + "/testcase" + i + ".txt";
											var exeCommand = 'python ' + './temp/' + userName + '/' + userName + '.py' + ' < ' + inputfileCommand
											callCompiler(exeCommand, filename, progNotFinished, userName, path, i, fn);
											i++;
										}
										// 	}
										// });
									}
								});
							}
						})
					}	//end of else err
				}	//end of exports.stats
			});	//end of write file 	
		}
	});
} //end of compileCPPWithInput