var exec = require('child_process').exec;
var fs = require('fs');
var cuid = require('cuid');
var fetch = require('isomorphic-fetch');
var colors = require('colors');

var userOutput = [];
var testCaseLength = 0;
var userPath = null;
var userLanguage = null;
var userCode = null;
var userModuleId = null;

exports.stats = false;


exports.compileCS = function (envData, code, fn) {
	//creating source file
	var filename = cuid.slug();
	path = './temp/' + filename;


	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + '/temp.cs', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else
						console.log('INFO: '.green + filename + '.cs created');
				}
				if (envData.OS === 'linux') {

					//compile cs code 
					commmand = 'cd temp' + "/" + filename + ' && mcs temp.cs';
					exec(commmand, function (error, stdout, stderr) {
						if (error) {
							if (exports.stats) {
								console.log('INFO: '.green + filename + '.cs contained an error while compiling');
							}
							var out = { error: stderr };
							deleteData(path);
							fn(out);
						}
						else {
							var tempcommand = "cd temp" + "/" + filename + " && mono temp.exe";
							exec(tempcommand, function (error, stdout, stderr) {
								if (error) {

									if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
										var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
										deleteData(path);
										fn(out);
									}
									else {
										if (exports.stats) {
											console.log('INFO: '.green + filename + '.cs contained an error while executing');
										}

										var out = { error: stderr };
										deleteData(path);
										fn(out);
									}
								}
								else {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cs successfully compiled and executed !');
									}
									var out = { output: stdout };
									deleteData(path);
									fn(out);
								}
							});
						}

					});
				}
			});
		}
	})

	//compiling and exrcuiting source code

} //end of compileCS

deleteData = (path) => {
	command = "rm -r " + path;
	exec(command, function (err) {
		console.log(err);

	});
}


exports.compileCSWithInput = function (envData, code, input, fn) {
	var filename = cuid.slug();
	path = './temp/' + filename;

	//create temp0 
	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			fs.writeFile(path + '/temp.cs', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else
						console.log('INFO: '.green + filename + '.cs created');
				}

				if (envData.OS === 'linux') {

					//compile c code 
					// commmand = 'cd temp && mcs ' + filename + '.cs';
					commmand = 'cd temp' + '/' + filename + ' && mcs temp.cs'
					exec(commmand, function (error, stdout, stderr) {
						if (error) {
							if (exports.stats) {
								console.log('INFO: '.green + filename + '.cs contained an error while compiling');
							}
							var out = { error: stderr };
							deleteData(path);
							fn(out);
						}
						else {
							if (input) {
								var inputfile = 'temp.txt';

								fs.writeFile(path + "/" + inputfile, input, function (err) {
									if (exports.stats) {
										if (err)
											console.log('ERROR: '.red + err);
										else {
											console.log('INFO: '.green + inputfile + ' (inputfile) created');
											var tempcommand = "cd " + path + ' && ' + "./" + "temp.exe";
											// var tempcommand = "cd temp && " + "./" + filename + ".exe";

											exec(tempcommand + '<' + inputfile, function (error, stdout, stderr) {
												if (error) {
													if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
														var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
														deleteData(path);
														fn(out);
													}
													else {
														if (exports.stats) {
															console.log('INFO: '.green + filename + '.cs contained an error while executing');
														}
														var out = { error: stderr };
														deleteData(path);
														fn(out);
													}
												}
												else {
													if (exports.stats) {
														console.log('INFO: '.green + filename + '.cs successfully compiled and executed !');
													}
													var out = { output: stdout };
													deleteData(path);
													fn(out);
												}
											});

										}

									}
								});

							}
							else //input not provided 
							{
								if (exports.stats) {
									console.log('INFO: '.green + 'Input mission for ' + filename + '.cs');
								}
								var out = { error: 'Input Missing' };
								deleteData(path);
								fn(out);
							}

						}


					});	 //end of csc exec    							
				}



			});
		}
	});
	//end of writeFile


} //end of compileCPPWithInput

callCompiler = (exeCommand, filename, progNotFinished, userName, path, i, fn) => {
	exec(exeCommand, function (error, stdout, stderr) {
		if (error) {
			if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
				var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
				// deleteData(path);
				// fn(out);
			}
			else {
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cs contained an error while executing');
				}
				var out = { error: stderr };
				// deleteData(path);
				// fn(out);
			}
		}
		else {
			if (progNotFinished) {
				progNotFinished = false;
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cs successfully compiled and executed !');
				}
				var out = { output: stdout };

				inputfileName = userName + "testcase" + i + "output.txt";
				fs.writeFile(path + "/" + inputfileName, stdout.trim(), function (err) {
					if (exports.stats) {
						if (err)
							console.log('ERROR: '.red + err);
						else {
							console.log('INFO: '.green + inputfileName + ' (inputfileName) created');
							callCompareFunction(path, userName, inputfileName, i, stdout, fn);
						}
					}
				});
				// fn(out);
			}
		}
	});
}

getUserTestCaseOutputPath = (filePathCommandTestCase, outputFilePath, userName, i, testCaseOutput, fn) => {
	var UserTestCasePath = null;
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cs contained an error while compiling');
			}
			UserTestCasePath = { error: stderr };
			fn(out);
		}
		else {
			UserTestCasePath = stdout.trim();
			finalCompareFunction(UserTestCasePath, outputFilePath, userName, i, testCaseOutput, fn)
			// return UserTestCasePath;
		}
	});
}

getTestCaseOutputPath = (filePathCommandTestCase, userName, i, testCaseOutput, fn) => {
	var outputFilePath = null;
	var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cs contained an error while compiling');
			}
			outputFilePath = { error: stderr };
			fn(out);
		}
		else {
			outputFilePath = stdout.trim();
			getUserTestCaseOutputPath(filePathCommandTestCaseOutput, outputFilePath, userName, i, testCaseOutput, fn);
			// return outputFilePath;
		}
	});

	// getting the path for the UserName generated file folder
}

finalCompareFunction = (outputFilePath, UserTestCasePath, userName, i, testCaseOutput, fn) => {
	var testCaseOutputFilePath = outputFilePath + "/testcase" + i + "output.txt";
	var UserTestCaseOutputPath = UserTestCasePath + "/" + userName + "testcase" + i + "output.txt";
	// var changeCommand = "cd " + outputFilePath + " && " + ""
	// var input1= "temp/TestCaseOutput/testcase"+i+"output.txt"
	// var input2= "temp/"+userName+"/"+userName+"testcase"+i+"output.txt"
	var command = `diff -q ${testCaseOutputFilePath} ${UserTestCaseOutputPath}`;
	var localarray = {};
	exec(command, function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cs output did not matched with testcase');
			}
			var out = { error: stderr };
			localarray = {
				testCase: i,
				testStatus: "failed",
				testOutput: testCaseOutput.trim(),
			}
			// deleteData(path);
			// fn(out);
		}
		else {
			var out = stdout;
			console.log(out)
			if (out === '') {
				localarray = {
					testCase: i,
					testStatus: "passed",
					testOutput: testCaseOutput.trim(),
				}

			}
			// logic to calculate the score			
		}
		userOutput.push(localarray);
		// if (userOutput.length === testCaseLength) {
		// 	// userName,moduleId,language,code,output,passedTestCases,TestCases(Total)
		// 	console.log("dayadadf", userOutput);
		// 	var passedData = userOutput.filter((data) => { return data.testStatus === "passed" });
		// 	const URL = "http://172.30.13.201:4000/postUserCodeOutput";
		// 	let fetchData = {
		// 		method: 'POST',
		// 		body: JSON.stringify({
		// 			"userName": "honor",
		// 			"moduleId": "Praleso",
		// 			"language": userLanguage,
		// 			"code": userCode,
		// 			"output": JSON.stringify(userOutput),
		// 			"passedTestCases": passedData.length,
		// 			"testCases": testCaseLength
		// 		}),

		// 		headers: {
		// 			Accept: "application/json",
		// 			"Content-Type": "application/json"
		// 		}
		// 	}
		// 	fetch(URL, fetchData)
		// 		.then(resonse => resonse.json())
		// 		.then((responseJson) => {
		// 			console.log(responseJson);
		// 			var data = '';

		// 			if (responseJson.result) {
		// 				console.log(responseJson.result)
		// 				deleteData(userPath);
		// 				fn(userOutput)
		// 				userOutput = [];
		// 			}
		// 		})
		// 		.catch((err) => {
		// 			console.log(err);
		// 		});

		// }
		if (userOutput.length === testCaseLength) {
			deleteData(userPath);
			fn(userOutput);
			userOutput = [];
		}
	});
}

callCompareFunction = async (path, userName, inputfileName, i, testCaseOutput, fn) => {
	var testCaseOutputPath = "cd temp/TestCaseOutput/testcase" + i + "output.txt";
	var UserOutputPath = path + "/" + inputfileName;
	// var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	var filePathCommandTestCase = "cd temp/" + userName + ' && ' + "pwd"
	var outputFilePath = null;
	var UserTestCasePath = null;

	// getting the path for the TestCaseOutput folder
	outputFilePath = await getTestCaseOutputPath(filePathCommandTestCase, userName, i, testCaseOutput, fn);
	// UserTestCasePath = await getUserTestCaseOutputPath(filePathCommandTestCaseOutput, userName);
}

exports.compileCsharpWithTestCase = function (envData, code, userName, language, moduleId, fn) {
	var filename = cuid.slug();
	path = './temp/' + userName;
	userPath = path;
	userLanguage = language
	userCode = code;
	userModuleId = moduleId;

	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + '/' + userName + '.cs', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else {
						console.log('INFO: '.green + filename + '.cpp created');
						if (envData.OS === 'linux') {

							//compile c code

							commmand = 'cd temp/' + userName + ' && mcs ' + userName + '.cs';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + userName + '.cs contained an error while compiling');
									}
									var out = { error: stderr };
									deleteData(path);
									fn(out);
								}
								else {
									var progNotFinished = true;
									var tempcommand = "cd temp" + "/" + userName + " && " + "./" + userName + ".exe";
									var countOfFileCommand = "cd temp/TestCase" + " && " + "ls | wc -l";
									var filePath = null;
									var filePathcommand = "cd temp/TestCase" + ' && ' + "pwd"
									exec(filePathcommand, function (error, stdout, stderr) {
										if (error) {
											if (exports.stats) {
												console.log('INFO: '.green + userName + '.cs contained an error while compiling');
											}
											filePath = { error: stderr };
											deleteData(path);
											fn(out);
										}
										else {
											filePath = stdout.trim();
										}
									})

									exec(countOfFileCommand, function (error, stdout, stderr) {
										if (error) {
											if (exports.stats) {
												console.log('INFO: '.green + userName + '.cs contained an error while compiling');
											}
											var out = { error: stderr };
											deleteData(path);
											// fn(out);
										}
										else {
											var countOfFile = Number(stdout);
											testCaseLength = countOfFile;
											var i = 1;
											while (i <= countOfFile) {
												var inputfileCommand = filePath + "/testcase" + i + ".txt";
												var exeCommand = tempcommand + ' < ' + inputfileCommand
												callCompiler(exeCommand, filename, progNotFinished, userName, path, i, fn);
												i++;
											}

										}
									});


								}

							});
						}
						else {
							console.log('ERROR: '.red + 'choose either g++ or gcc ');
						}
					}
				}
			});
		}
	});
} 