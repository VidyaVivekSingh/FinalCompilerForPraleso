var exec = require('child_process').exec;
var fs = require('fs');
var cuid = require('cuid');
var fetch = require('isomorphic-fetch');
var colors = require('colors');

var userOutput = [];
var testCaseLength = 0;
var userPath = null;
var userLanguage = null;
var userCode = null;
var userModuleId = null;


exports.stats = false;


exports.compileCPP = function (envData, code, fn) {
	//creating source file
	var filename = cuid.slug();
	path = './temp/' + filename;


	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0
			gotofolder = "cd temp/" + filename
			fs.writeFile(path + '/temp.cpp', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else {
						console.log('INFO: '.green + filename + '.cpp created');
						//compiling and exrcuiting source code
						if (envData.cmd === 'g++') {

							//compile c code
							commmand = 'g++ ' + path + '/temp.cpp -o ' + path + '/temp.exe';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
									}
									var out = { error: stderr };
									deleteData(path);
									fn(out);
								}
								else {
									var progNotFinished = true;
									var tempcommand = "cd " + "temp/" + filename + " && " + "./temp.exe";
									exec(tempcommand, function (error, stdout, stderr) {
										if (error) {

											if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
												var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
												deleteData(path);
												fn(out);
											}
											else {
												if (exports.stats) {
													console.log('INFO: '.green + filename + '.cpp contained an error while executing');
												}

												var out = { error: stderr };
												deleteData(path);
												fn(out);
											}
										}
										else {
											if (progNotFinished) {
												progNotFinished = false;// programme finished
												if (exports.stats) {
													console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
												}
												var out = { output: stdout };
												deleteData(path);
												fn(out);
											}
										}
									});
									if (envData.options.timeout) {
										// kill the programme after envData.options.timeout ms
										setTimeout(function () {
											exec("taskkill /im " + path + "temp.exe /f > nul", function (error, stdout, stderr) {
												if (progNotFinished) {
													progNotFinished = false;// programme finished
													if (exports.stats) {
														console.log('INFO: '.green + filename + '.exe was killed after ' + envData.options.timeout + 'ms');
													}
													var out = { timeout: true };
													// fn(out);
												}
											});
										}, envData.options.timeout);
									}
								}

							});


						}
						else if (envData.cmd === 'gcc') {
							//compile c code
							commmand = 'gcc ' + path + filename + '.cpp -o ' + path + filename + '.out';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
									}
									var out = { error: stderr };
									deleteData(path);
									fn(out);
								}
								else {
									exec(path + filename + '.out', function (error, stdout, stderr) {
										if (error) {
											if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
												var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
												deleteData(path);
												fn(out);
											}
											else {
												if (exports.stats) {
													console.log('INFO: '.green + filename + '.cpp contained an error while executing');
												}
												var out = { error: stderr };
												fn(out);
											}
										}
										else {
											if (exports.stats) {
												console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
											}
											var out = { output: stdout };
											deleteData(path);
											fn(out);
										}
									});

								}
							});
						}
						else {
							console.log('ERROR: '.red + 'choose either g++ or gcc ');
						}
					}	//end of else part of err
				}	//end of expors.stats
			}); //end of write file
		}
	})


} //end of compileCPP

deleteData = (path) => {
	command = "rm -r " + path;
	exec(command, function (err) {
		console.log(err);

	});
}

exports.compileCPPWithInput = function (envData, code, input, fn) {
	var filename = cuid.slug();
	path = './temp/' + filename;

	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + '/temp.cpp', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else {
						console.log('INFO: '.green + filename + '.cpp created');
						if (envData.cmd === 'g++') {

							//compile c code
							commmand = 'g++ ' + path + '/temp.cpp -o ' + path + '/temp.exe';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
									}
									var out = { error: stderr };
									deleteData(path);
									fn(out);
								}
								else {
									if (input) {
										var inputfile = 'temp.txt';
										fs.writeFile(path + "/" + inputfile, input, function (err) {
											if (exports.stats) {
												if (err)
													console.log('ERROR: '.red + err);
												else
													console.log('INFO: '.green + inputfile + ' (inputfile) created');
											}
											var progNotFinished = true;
											var tempcommand = "cd temp" + "/" + filename + " && " + "./" + "temp.exe";

											exec(tempcommand + '<' + inputfile, function (error, stdout, stderr) {
												if (error) {
													if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
														var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
														deleteData(path);
														fn(out);
													}
													else {
														if (exports.stats) {
															console.log('INFO: '.green + filename + '.cpp contained an error while executing');
														}
														var out = { error: stderr };
														deleteData(path);
														fn(out);
													}
												}
												else {
													if (progNotFinished) {
														progNotFinished = false;
														if (exports.stats) {
															console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
														}
														var out = { output: stdout };
														deleteData(path);
														fn(out);
													}
												}
											});
											if (envData.options.timeout) {
												// kill the programme after envData.options.timeout ms
												setTimeout(function () {
													exec("taskkill /im " + path + "temp.exe /f > nul", function (error, stdout, stderr) {
														if (progNotFinished) {
															progNotFinished = false;// programme finished
															if (exports.stats) {
																console.log('INFO: '.green + filename + '.exe was killed after ' + envData.options.timeout + 'ms');
															}
															var out = { timeout: true };
															deleteData(path);
															// fn(out);
														}
													});
												}, envData.options.timeout);
											}
										});


									}
									else //input not provided
									{
										if (exports.stats) {
											console.log('INFO: '.green + 'Input mission for ' + filename + '.cpp');
										}
										var out = { error: 'Input Missing' };
										// deleteData(path);
										fn(out);
									}

								}


							});

						}
						else if (envData.cmd == 'gcc') {
							//compile c code
							commmand = 'gcc ' + path + filename + '.cpp -o ' + path + filename + '.out';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
									}
									var out = { error: stderr };
									// deleteData(path);
									fn(out);
								}
								else {
									if (input) {
										var inputfile = filename + 'input.txt';

										fs.writeFile(path + inputfile, input, function (err) {
											if (exports.stats) {
												if (err)
													console.log('ERROR: '.red + err);
												else
													console.log('INFO: '.green + inputfile + ' (inputfile) created');
											}
										});

										exec(path + filename + '.out' + ' < ' + path + inputfile, function (error, stdout, stderr) {
											if (error) {

												if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
													var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
													deleteData(path);
													fn(out);
												}
												else {
													if (exports.stats) {
														console.log('INFO: '.green + filename + '.cpp contained an error while executing');
													}
													var out = { output: stderr };
													deleteData(path);
													fn(out);
												}
											}
											else {
												if (exports.stats) {
													console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
												}
												var out = { output: stdout };
												deleteData(path);
												fn(out);
											}
										});

									}
									else //no input file
									{
										if (exports.stats) {
											console.log('INFO: '.green + 'Input mission for ' + filename + '.cpp');
										}
										var out = { error: 'Input Missing' };
										deleteData(path);
										fn(out);
									}
								}
							});
						}
						else {
							console.log('ERROR: '.red + 'choose either g++ or gcc ');
						}
					}	//end of else err
				}	//end of exports.stats
			});	//end of write file 	
		}
	});
} //end of compileCPPWithInput


callCompiler = (exeCommand, filename, progNotFinished, userName, path, i, fn) => {
	exec(exeCommand, function (error, stdout, stderr) {
		if (error) {
			if (error.toString().indexOf('Error: stdout maxBuffer exceeded') != -1) {
				var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
				// deleteData(path);
				// fn(out);
			}
			else {
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cpp contained an error while executing');
				}
				var out = { error: stderr };
				// deleteData(path);
				// fn(out);
			}
		}
		else {
			if (progNotFinished) {
				progNotFinished = false;
				if (exports.stats) {
					console.log('INFO: '.green + filename + '.cpp successfully compiled and executed !');
				}
				var out = { output: stdout };

				inputfileName = userName + "testcase" + i + "output.txt";
				fs.writeFile(path + "/" + inputfileName, stdout, function (err) {
					if (exports.stats) {
						if (err)
							console.log('ERROR: '.red + err);
						else {
							console.log('INFO: '.green + inputfileName + ' (inputfileName) created');
							callCompareFunction(path, userName, inputfileName, i, stdout, fn);
						}
					}
				});
				// fn(out);
			}
		}
	});
}

getUserTestCaseOutputPath = (filePathCommandTestCase, outputFilePath, userName, i, testCaseOutput, fn) => {
	var UserTestCasePath = null;
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cpp contained an error while compiling');
			}
			UserTestCasePath = { error: stderr };
			fn(out);
		}
		else {
			UserTestCasePath = stdout.trim();
			finalCompareFunction(UserTestCasePath, outputFilePath, userName, i, testCaseOutput, fn)
			// return UserTestCasePath;
		}
	});
}

getTestCaseOutputPath = (filePathCommandTestCase, userName, i, testCaseOutput, fn) => {
	var outputFilePath = null;
	var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	exec(filePathCommandTestCase, async function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + '.cpp contained an error while compiling');
			}
			outputFilePath = { error: stderr };
			fn(out);
		}
		else {
			outputFilePath = stdout.trim();
			getUserTestCaseOutputPath(filePathCommandTestCaseOutput, outputFilePath, userName, i, testCaseOutput, fn);
			// return outputFilePath;
		}
	});

	// getting the path for the UserName generated file folder
}

finalCompareFunction = (outputFilePath, UserTestCasePath, userName, i, testCaseOutput, fn) => {
	var testCaseOutputFilePath = outputFilePath + "/testcase" + i + "output.txt";
	var UserTestCaseOutputPath = UserTestCasePath + "/" + userName + "testcase" + i + "output.txt";
	// var changeCommand = "cd " + outputFilePath + " && " + ""
	// var input1= "temp/TestCaseOutput/testcase"+i+"output.txt"
	// var input2= "temp/"+userName+"/"+userName+"testcase"+i+"output.txt"
	var command = `diff -q ${testCaseOutputFilePath} ${UserTestCaseOutputPath}`;
	var localarray = {};
	exec(command, function (error, stdout, stderr) {
		if (error) {
			if (exports.stats) {
				console.log('INFO: '.green + userName + 'compare is not done');
			}
			var out = { error: stderr };
			localarray = {
				testCase: i,
				testStatus: "failed",
				testOutput: testCaseOutput,
			}
			// deleteData(path);
			// fn(out);
		}
		else {
			var out = stdout;
			console.log(out)
			if (out === '') {
				localarray = {
					testCase: i,
					testStatus: "passed",
					testOutput: testCaseOutput,
				}

			}
			// logic to calculate the score			
		}
		userOutput.push(localarray);
		if (userOutput.length === testCaseLength) {
			// userName,moduleId,language,code,output,passedTestCases,TestCases(Total)
			console.log("dayadadf", userOutput);
			var passedData = userOutput.filter((data) => { return data.testStatus === "passed" });
			const URL = "http://172.30.13.201:4000/postUserCodeOutput";
			let fetchData = {
				method: 'POST',
				body: JSON.stringify({
					"userName": userName,
					"moduleId": userModuleId,
					"language": userLanguage,
					"code": userCode,
					"output": JSON.stringify(userOutput),
					"passedTestCases": passedData.length,
					"testCases": testCaseLength,					
				}),

				headers: {
					Accept: "application/json",
					"Content-Type": "application/json"
				}
			}
			fetch(URL, fetchData)
				.then(resonse => resonse.json())
				.then((responseJson) => {
					console.log(responseJson);
					var data = '';

					if (responseJson.result) {
						console.log(responseJson.result)
						deleteData(userPath);
						fn(userOutput)
						userOutput = [];
					}
				})
				.catch((err) => {
					console.log(err);
				});

		}
	});
}

callCompareFunction = async (path, userName, inputfileName, i, testCaseOutput, fn) => {
	var testCaseOutputPath = "cd temp/TestCaseOutput/testcase" + i + "output.txt";
	var UserOutputPath = path + "/" + inputfileName;
	// var filePathCommandTestCaseOutput = "cd temp/TestCaseOutput" + ' && ' + "pwd"
	var filePathCommandTestCase = "cd temp/" + userName + ' && ' + "pwd"
	var outputFilePath = null;
	var UserTestCasePath = null;

	// getting the path for the TestCaseOutput folder
	outputFilePath = await getTestCaseOutputPath(filePathCommandTestCase, userName, i, testCaseOutput, fn);
	// UserTestCasePath = await getUserTestCaseOutputPath(filePathCommandTestCaseOutput, userName);
}

exports.compileCPPWithTestCase = function (envData, code, userName, language, moduleId, fn) {
	var filename = cuid.slug();
	path = './temp/' + userName;
	userPath = path;
	userLanguage = language;
	userCode = code;
	userModuleId = moduleId;

	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + '/' + userName + '.cpp', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else {
						console.log('INFO: '.green + filename + '.cpp created');
						if (envData.cmd === 'g++') {

							//compile c code

							commmand = 'g++ ' + path + '/' + userName + '.cpp -o ' + path + '/' + userName + '.exe';
							exec(commmand, function (error, stdout, stderr) {
								if (error) {
									if (exports.stats) {
										console.log('INFO: '.green + userName + '.cpp contained an error while compiling');
									}
									var out = { error: stderr };
									deleteData(path);
									fn(out);
								}
								else {
									var progNotFinished = true;
									var tempcommand = "cd temp" + "/" + userName + " && " + "./" + userName + ".exe";
									var countOfFileCommand = "cd temp/TestCase" + " && " + "ls | wc -l";
									var filePath = null;
									var filePathcommand = "cd temp/TestCase" + ' && ' + "pwd"
									exec(filePathcommand, function (error, stdout, stderr) {
										if (error) {
											if (exports.stats) {
												console.log('INFO: '.green + userName + 'temp/TestCase Path did not found ');
											}
											filePath = { error: stderr };
											deleteData(path);
											fn(out);
										}
										else {
											filePath = stdout.trim();
										}
									})

									exec(countOfFileCommand, function (error, stdout, stderr) {
										if (error) {
											if (exports.stats) {
												console.log('INFO: '.green + userName + 'count of file is not done');
											}
											var out = { error: stderr };
											deleteData(path);
											// fn(out);
										}
										else {
											var countOfFile = Number(stdout);
											testCaseLength = countOfFile;
											var i = 1;
											while (i <= countOfFile) {
												var inputfileCommand = filePath + "/testcase" + i + ".txt";
												var exeCommand = tempcommand + ' < ' + inputfileCommand
												callCompiler(exeCommand, filename, progNotFinished, userName, path, i, fn);
												i++;
											}

										}
									});


								}

							});
						}
						else {
							console.log('ERROR: '.red + 'choose either g++ or gcc ');
						}
					}
				}
			});
		}
	});
}

